// Copyright (c) 2020 Abhishek Mishra
// 
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

/**
 * \file cliutils.h
 * \brief Cliutils main header file. Defines the Public API of cliutils.
 */

#ifndef SRC_CLI_COMMAND_H_
#define SRC_CLI_COMMAND_H_

#include "cli_common.h"

#include <coll_arraylist.h>
#include <lua.h>
#include <lauxlib.h>
#include "cli_table.h"
#include "cli_dict.h"
#include "cli_progress.h"

#ifdef __cplusplus  
extern "C" {
#endif

/** Help option long name */
#define CLI_OPTION_HELP_LONG "help"
/** Help option short name */
#define CLI_OPTION_HELP_SHORT "h"
/** Help option description */
#define CLI_OPTION_HELP_DESC "Print help for command."

/**
 * @brief This enum defines the possible error codes 
 * 	generated by functions in the API.
 */
typedef enum
{
	CLI_COMMAND_IS_RUNNING = -1,
	CLI_COMMAND_SUCCESS = 0,
	CLI_COMMAND_ERR_UNKNOWN = 1,
	CLI_COMMAND_ERR_ALLOC_FAILED = 2,
	CLI_COMMAND_ERR_COMMAND_NOT_FOUND = 3,
	CLI_COMMAND_ERR_OPTION_NOT_FOUND = 4,
	CLI_COMMAND_ERR_ARG_NOT_FOUND = 5,
	CLI_COMMAND_ERR_EXTRA_ARGS_FOUND = 6
} cli_cmd_err;

/**
 * @brief This enum defines the possible datatypes of 
 * 	argument or option values
 */
typedef enum
{
	CLI_TYPE_BOOLEAN = 0,
	CLI_TYPE_INT = 1,
	CLI_TYPE_DOUBLE = 2,
	CLI_TYPE_STRING = 3,
	CLI_TYPE_FLAG = 4
} cli_type;

/**
 * @brief This enum defines the possible types of result 
 * 	cli program might output.
 */
typedef enum
{
	CLI_RESULT_STRING = 0,
	CLI_RESULT_TABLE = 1,
	CLI_RESULT_DICT = 2,
	CLI_RESULT_PROGRESS = 3
} cli_result_type;

//TODO add defaults
/**
 * @brief This struct holds the value of the argument or option.
 * 
 */
typedef struct cli_val_t
{
	cli_type type;		///< type of value
	int bool_value;		///< boolean value
	int int_value;		///< integer value
	double dbl_value;	///< double value
	char* str_value;	///< string value
} cli_val;

/**
 * @brief Convert a cli value to its lua value
 * 
 * @param L Lua state
 * @param val value
 * @return int indicating error
 */
MODULE_API int cli_val_to_lua(lua_State *L, cli_val* val);

/**
 * @brief Create a cli val object
 * 
 * @param type type of the val
 * @param bool_val boolean value
 * @param int_val integer value
 * @param dbl_val double value
 * @param str  string value
 * @return MODULE_API* 
 */
MODULE_API cli_val* create_cli_val(cli_type type, int bool_val, 
	int int_val, double dbl_val, char* str);

/**
 * @brief Create a new flag cli value
 * 
 * @param v value
 */
#define CLI_VAL_FLAG(v) create_cli_val(CLI_TYPE_FLAG, v, 0, 0, NULL)

/**
 * @brief Create a new boolean cli value
 * 
 * @param v value
 */
#define CLI_VAL_BOOLEAN(v) create_cli_val(CLI_TYPE_BOOLEAN, v, 0, 0, NULL)

/**
 * @brief Create a new integer cli value
 * 
 * @param v value
 */
#define CLI_VAL_INT(v) create_cli_val(CLI_TYPE_INT, 0, v, 0, NULL)

/**
 * @brief Create a new double cli value
 * 
 * @param v value
 */
#define CLI_VAL_DOUBLE(v) create_cli_val(CLI_TYPE_DOUBLE, 0, 0, v, NULL)

/**
 * @brief Create a new string cli value
 * 
 * @param v value
 */
#define CLI_VAL_STRING(v) create_cli_val(CLI_TYPE_STRING, 0, 0, 0, v)

/**
 * @brief CLI Option Object
 */
typedef struct cli_option_t
{
	char* name;				///< name of the option
	char* short_name;		///< short_name of the option
	cli_val* val;			///< value of the option
	cli_val* default_val;	///< default value of the option
	char* description;		///< textural description of the option
} cli_option;

/**
 * @brief Convert the cli option to a lua value
 * 
 * @param L lua state
 * @param option option object
 * @return int error code
 */
MODULE_API int cli_option_to_lua(lua_State *L, cli_option* option);

/**
 * @brief Utility conversion function passed to arraylist to convert all entries to lua options
 * 
 * @param L lua state
 * @param index 
 * @param data must be a cli_option*
 */
MODULE_API void arraylist_cli_option_to_lua(lua_State *L, int index, void *data);

/**
 * @brief CLI Argument object
 */
typedef struct cli_argument_t
{
	char* name;				///< name of the argument
	cli_val* val;			///< value of the argument
	cli_val* default_val;	///< default value of the argument
	char* description;		///< textual description
	int optional;			///< flag indicating if argument is optional
} cli_argument;

/**
 * @brief Convert a cli argument to a lua object
 * 
 * @param L lua state
 * @param arg cli argument
 * @return int error code
 */
MODULE_API int cli_argument_to_lua(lua_State *L, cli_argument* arg);

/**
 * @brief Utility conversion function passed to arraylist to convert all entries to lua
 * 
 * @param L lua state
 * @param index
 * @param data must be a cli_argument*
 */
MODULE_API void arraylist_cli_argument_to_lua(lua_State *L, int index, void *data);

/**
 * @brief Fill the entries in the given option array into an arraylist
 * 
 * @param optlist arraylist to fill
 * @param options options array to use
 */
MODULE_API void cli_fill_options_in_list(arraylist* optlist, cli_option* options[]);

/**
 * @brief Defines a function to handle command output
 */
typedef cli_cmd_err(*zclk_command_output_handler)(cli_cmd_err result_flag,
	cli_result_type result_type, void* result);

/**
 * @brief defines a function to handle a command
 */
typedef cli_cmd_err(*zclk_command_handler)(void* handler_args,
	arraylist* options, arraylist* args,
	zclk_command_output_handler success_handler,
	zclk_command_output_handler error_handler);

/**
 * @brief A CLI Command Ojbect
 */
typedef struct zclk_command_t
{
	char* name;						///< name of the command
	char* short_name;				///< short name of the command
	char* description;				///< textual description
	arraylist* sub_commands;		///< list of subcommands
	arraylist* options;				///< options list
	arraylist* args;				///< args list
	zclk_command_handler handler;	///< command handler function
} zclk_command;

/**
 * Create a new value object of given type.
 *
 * \param val object to create
 * \param type
 * \return error code
 */
MODULE_API cli_cmd_err make_cli_val(cli_val** val, cli_type type);

/**
 * Free the created value
 */
MODULE_API void free_cli_val(cli_val* val);

/**
 * Reset values to system defaults.
 */
MODULE_API void clear_cli_val(cli_val* val);

/**
 * Copy values from 'from' to 'to'.
 * Can be used to reset to defaults.
 *
 * \param to val to set
 * \param from val to read from
 */
MODULE_API void copy_cli_val(cli_val* to, cli_val* from);

/**
 * Parse the input and read the value of the type of the val object.
 * (Should not be called when the values is a flag.)
 * The value should be set as soon as the argument/option is seen
 *
 * \param val object whose value will be set
 * \param input string input
 * \return error code
 */
MODULE_API cli_cmd_err parse_cli_val(cli_val* val, char* input);

/**
 * Create a new option given a name and type.
 *
 * \param option object to create
 * \param name
 * \param short_name
 * \param val
 * \param default_val
 * \param description
 * \return error code
 */
MODULE_API cli_cmd_err make_option(cli_option** option, char* name, 
	char* short_name, cli_val* val, cli_val* default_val, char* description);

/**
 * @brief (Internal use) Create a option object
 * 
 * @param name 
 * @param short_name 
 * @param val 
 * @param default_val 
 * @param desc 
 * @return MODULE_API* 
 */
MODULE_API cli_option* create_option(char* name, char* short_name, 
	cli_val* val, cli_val* default_val, char* desc);

/**
 * Free resources used by option
 * 
 * @param option to free
 */
MODULE_API void free_option(cli_option* option);

/**
 * @brief Get the option by name object
 * 
 * @param options options list
 * @param name name of option to retrieve
 * @return cli_option* option with the given name
 */
MODULE_API cli_option* get_option_by_name(arraylist* options, char* name);

/**
 * Create a new argument given a name and type.
 *
 * \param arg object to create
 * \param name
 * \param val
 * \param default_val
 * \param desc
 * \return error code
 */
MODULE_API cli_cmd_err make_argument(cli_argument** arg, char* name, 
	cli_val* val, cli_val* default_val, char* desc);

/**
 * @brief (Internal use only) Create a argument object
 * 
 * @param name 
 * @param val 
 * @param default_val 
 * @param desc 
 * @return MODULE_API* 
 */
MODULE_API cli_argument* create_argument(char* name, cli_val* val, 
	cli_val* default_val, char* desc);

/**
 * Free resources used by argument
 */
MODULE_API void free_argument(cli_argument* arg);

/**
 * Create a new command with the given name and handler
 * Options and sub-commands need to be added after creation.
 * The sub-commands, arguments and options lists will be initialized,
 * so one just needs to add items using the arraylist add function.
 *
 * \param command obj to be created
 * \param name
 * \param short_name
 * \param description
 * \param handler function ptr to handler
 * \return error code
 */
MODULE_API cli_cmd_err make_command(zclk_command** command, char* name, 
	char* short_name, char* description, zclk_command_handler handler);

/**
 * @brief Create a command object with automatic error handling
 * @see make_command
 * 
 * @param name 
 * @param short_name 
 * @param description 
 * @param handler 
 * @return zclk_command* created command object
 */
MODULE_API zclk_command* zclk_command_new(
							char* name, 
							char* short_name,
    						char* description, 
							zclk_command_handler handler
						);

/**
 * @brief Add a subcommand to the given command
 * 
 * @param cmd command
 * @param subcommand subcommand to add
 * @return error code
 */
MODULE_API cli_cmd_err zclk_command_subcommand_add(
							zclk_command *cmd,
							zclk_command *subcommand
						);

/**
 * @brief Add an option to the given command
 * 
 * @param cmd command
 * @param option option to add
 * @return error code
 */
MODULE_API cli_cmd_err zclk_command_option_add(
							zclk_command *cmd,
							cli_option* option
						);

/**
 * @brief Add an argument to the given command
 * 
 * @param cmd command
 * @param arg argument to add
 * @return error code
 */
MODULE_API cli_cmd_err zclk_command_argument_add(
							zclk_command *cmd,
							cli_argument* arg
						);

/**
 * @brief Execute the command with the given args
 * 
 * @param cmd Command to execute
 * @param argc arg count
 * @param argv arg values
 * @return error code
 */
MODULE_API cli_cmd_err zclk_command_exec(
							zclk_command* cmd, 
							int argc, char* argv[]
						);

/**
 * Free a command object
 */
MODULE_API void free_command(zclk_command* command);

/**
* Get help for a command
* \param cmds_to_exec the list of commands and subcommands parsed
* \return string with command help
*/
MODULE_API char* get_help_for_command(arraylist* cmds_to_exec);

/**
 * Run the help command for all commands or single command
 *
 * \param commands the list of commands registered 
 * 						(this is a list of zclk_command*)
 * \param handler_args an args value to be passed to the command handler
 * \param argc the number of tokens in the line
 * \param argv args as an array of strings
 * \param success_handler handle success results
 * \param error_handler handler error results
 */
MODULE_API cli_cmd_err help_cmd_handler(arraylist* commands, 
	void* handler_args,	int argc, char** argv, 
	zclk_command_output_handler success_handler,
	zclk_command_output_handler error_handler);

/**
 * Get the help string for the arg_commands from the registered commands list.
 * \param help_str the help string to return
 * \param commands is the configured list of commands
 * \param arg_commands is a list of string
 * \return error code
 */
MODULE_API cli_cmd_err get_help_for(char** help_str, arraylist* commands,
	arraylist* arg_commands);

/**
 * Execute a single line containing one top-level command.
 * All output is written to stdout, all errors to stderr
 *
 * \param commands the list of commands registered 
 * 						(this is a list of zclk_command*)
 * \param handler_args an args value to be passed to the command handler
 * \param argc the number of tokens in the line
 * \param argv args as an array of strings
 * \param success_handler handle success results
 * \param error_handler handler error results
 */
MODULE_API cli_cmd_err exec_command(arraylist* commands, void* handler_args,
	int argc, char** argv, zclk_command_output_handler success_handler,
	zclk_command_output_handler error_handler);

/**
 * @brief Print a tabular result object to the stdout
 * 
 * @param result table result object
 */
MODULE_API void print_table_result(void* result);

/**
 * @brief A Print handler prints the result of the command
 * 
 * @param result_flag error flag
 * @param res_type result type
 * @param result result object
 * @return error code
 */
MODULE_API cli_cmd_err print_handler(cli_cmd_err result_flag, 
	cli_result_type res_type,
    void* result);

#ifdef __cplusplus 
}
#endif

#endif /* SRC_CLI_COMMAND_H_ */
